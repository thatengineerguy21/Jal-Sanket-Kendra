index.html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Water Quality Dashboard</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

package.json
{
  "name": "web",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4.1.13",
    "@vitejs/plugin-react": "^5.0.4",
    "autoprefixer": "^10.4.21",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.13",
    "vite": "^7.1.7"
  },
  "dependencies": {
    "jspdf": "^3.0.3",
    "jspdf-autotable": "^5.0.2",
    "leaflet": "^1.9.4",
    "papaparse": "^5.5.3",
    "react-leaflet": "^5.0.0",
    "react-router-dom": "^7.9.3"
  }
}

postcss.config.js
import tailwindcss from '@tailwindcss/postcss'
import autoprefixer from 'autoprefixer'

export default {
  plugins: [tailwindcss(), autoprefixer()],
};

tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    './index.html',
    './src/**/*.{js,ts,jsx,tsx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};

vite.config.js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  base: '/app/',
  plugins: [react()],
  build: {
    outDir: '../static',
    emptyOutDir: false,
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://127.0.0.1:8000',
        changeOrigin: true,
        secure: false,
      },
    },
  },
})

App.jsx
import React, { useEffect, useMemo, useState } from 'react'
import { Link, Routes, Route, useNavigate } from 'react-router-dom'
import DataView from './pages/DataView.jsx'
import MapView from './pages/MapView.jsx'
import PredictView from './pages/PredictView.jsx'

const API_BASE = '/api/v1'

function NavBar() {
  const nav = useNavigate()
  return (
    <header className="flex items-center justify-between px-4 py-3 border-b border-slate-700 bg-slate-900 text-slate-200">
      <div className="font-semibold">Heavy Metal Pollution Dashboard</div>
      <nav className="flex gap-4 text-slate-300">
        <Link to="/data" className="hover:text-cyan-300">Data</Link>
        <Link to="/map" className="hover:text-cyan-300">Map</Link>
        <Link to="/predict" className="hover:text-cyan-300">Predict</Link>
        <button className="px-2 py-1 rounded bg-slate-700 hover:bg-slate-600" onClick={() => nav('/')}>
          Home
        </button>
      </nav>
    </header>
  )
}

export default function App() {
  const [samples, setSamples] = useState([])
  const [preds, setPreds] = useState([])
  const [summary, setSummary] = useState(null)

  useEffect(() => {
    fetch(`${API_BASE}/indices/`).then(r=>r.json()).then(setSummary).catch(()=>{})
  }, [samples])

  return (
    <div className="min-h-screen text-slate-100 bg-gradient-to-b from-slate-900 via-slate-900 to-slate-800">
      <NavBar />
      <main className="grid grid-cols-1 lg:grid-cols-[420px,1fr]">
        <section className="bg-slate-900/80 backdrop-blur border-r border-slate-700 p-6">
          <h2 className="text-cyan-300 font-semibold mb-3">Indices Summary</h2>
          {summary ? (
            <div className="grid grid-cols-3 gap-3 text-sm">
              <div className="bg-slate-800 p-4 rounded shadow-sm hover:shadow-md transition">Count: <b>{summary.count}</b></div>
              <div className="bg-slate-800 p-4 rounded shadow-sm hover:shadow-md transition">Avg HPI: <b>{summary.avg_hpi}</b></div>
              <div className="bg-slate-800 p-4 rounded shadow-sm hover:shadow-md transition">Avg Cd: <b>{summary.avg_cd}</b></div>
            </div>
          ) : (
            <div className="text-slate-400 text-sm">No indices yet.</div>
          )}
        </section>
        <section className="min-h-[calc(100vh-56px)]">
          <Routes>
            <Route path="/" element={<DataView samples={samples} setSamples={setSamples} />} />
            <Route path="/data" element={<DataView samples={samples} setSamples={setSamples} />} />
            <Route path="/map" element={<MapView samples={samples} preds={preds} />} />
            <Route path="/predict" element={<PredictView preds={preds} setPreds={setPreds} />} />
          </Routes>
        </section>
      </main>
    </div>
  )
}

index.css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --bg: #0f172a;
}
body { background: var(--bg); }

main.jsx
import React from 'react'
import { createRoot } from 'react-dom/client'
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom'
import './index.css'
import 'leaflet/dist/leaflet.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <BrowserRouter basename="/app">
      <Routes>
        <Route path="/*" element={<App />} />
        <Route path="*" element={<Navigate to="/" replace />} />
      </Routes>
    </BrowserRouter>
  </React.StrictMode>
)

main.js
import './style.css'
import javascriptLogo from './javascript.svg'
import viteLogo from '/vite.svg'
import { setupCounter } from './counter.js'

document.querySelector('#app').innerHTML = `
  <div>
    <a href="https://vite.dev" target="_blank">
      <img src="${viteLogo}" class="logo" alt="Vite logo" />
    </a>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank">
      <img src="${javascriptLogo}" class="logo vanilla" alt="JavaScript logo" />
    </a>
    <h1>Hello Vite!</h1>
    <div class="card">
      <button id="counter" type="button"></button>
    </div>
    <p class="read-the-docs">
      Click on the Vite logo to learn more
    </p>
  </div>
`

setupCounter(document.querySelector('#counter'))

/pages/DataView.jsx
import React, { useEffect, useRef, useState } from 'react'
import Papa from 'papaparse'
import jsPDF from 'jspdf'
import autoTable from 'jspdf-autotable'

const API = (path) => new URL(path, window.location.origin).toString()

export default function DataView({ samples, setSamples }) {
  const [busy, setBusy] = useState(false)
  const [error, setError] = useState('')
  const [message, setMessage] = useState('')
  const fileRef = useRef(null)

  const load = async () => {
    try {
      const res = await fetch(API('/api/v1/datasets/'))
      const data = await res.json()
      setSamples(data)
    } catch (e) {
      // ignore
    }
  }

  useEffect(() => { load() }, [])

  const upload = async (e) => {
    e.preventDefault()
    setError(''); setMessage('')
    const f = fileRef.current?.files?.[0]
    if (!f) { setError('Select a CSV/JSON/PDF/Excel file.'); return }
    const fd = new FormData()
    fd.append('file', f, f.name)
    setBusy(true)
    try {
      const res = await fetch(API('/api/v1/upload-and-calculate/'), { method: 'POST', body: fd })
      if (!res.ok) throw new Error(await res.text())
      const data = await res.json()
      setSamples(data)
      setMessage(`Processed ${data.length} samples`)
    } catch (err) {
      setError(String(err))
    } finally { setBusy(false) }
  }

  const exportCSV = () => {
    const rows = (samples || []).map(s => ({
      latitude: s.latitude,
      longitude: s.longitude,
      arsenic: s.arsenic,
      cadmium: s.cadmium,
      lead: s.lead,
      zinc: s.zinc,
      HPI: s.result?.heavy_metal_pollution_index,
      HPI_Category: s.result?.hpi_category,
      Cd: s.result?.degree_of_contamination,
      Cd_Category: s.result?.cd_category,
    }))
    const csv = Papa.unparse(rows)
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = 'water_samples.csv'
    a.click()
    URL.revokeObjectURL(url)
  }

  const exportPDF = () => {
    const doc = new jsPDF({ orientation: 'landscape' })
    doc.text('Water Samples Report', 14, 14)
    const head = [['Latitude','Longitude','As','Cd','Pb','Zn','HPI','HPI Cat','Cd','Cd Cat']]
    const body = (samples || []).map(s => [
      s.latitude, s.longitude, s.arsenic, s.cadmium, s.lead, s.zinc,
      s.result?.heavy_metal_pollution_index, s.result?.hpi_category,
      s.result?.degree_of_contamination, s.result?.cd_category
    ])
    autoTable(doc, { head, body, startY: 20 })
    doc.save('water_samples.pdf')
  }

  return (
    <div className="p-4">
      <h2 className="text-cyan-300 font-semibold mb-2">Data</h2>
      <form onSubmit={upload} className="flex items-center gap-2">
        <input ref={fileRef} className="file:mr-3 file:px-3 file:py-2 file:bg-slate-700 file:border-0 file:text-slate-100 file:rounded" type="file" accept=".csv,.json,.pdf,.xlsx,.xls" />
        <button className="px-3 py-2 rounded bg-cyan-600 hover:bg-cyan-500" disabled={busy}>{busy? 'Uploading…' : 'Upload'}</button>
        <button type="button" onClick={load} className="px-3 py-2 rounded bg-slate-700 hover:bg-slate-600">Refresh</button>
        <button type="button" onClick={exportCSV} className="px-3 py-2 rounded bg-slate-700 hover:bg-slate-600">Export CSV</button>
        <button type="button" onClick={exportPDF} className="px-3 py-2 rounded bg-slate-700 hover:bg-slate-600">Export PDF</button>
      </form>
      {error && <div className="text-red-300 text-sm mt-2">{error}</div>}
      {message && <div className="text-green-300 text-sm mt-2">{message}</div>}
      <div className="mt-4 overflow-auto">
        <table className="min-w-full text-sm">
          <thead className="bg-slate-800 text-slate-200">
            <tr>
              {['Lat','Lng','As','Cd','Pb','Zn','HPI','HPI Cat','Cd','Cd Cat'].map(h => <th key={h} className="px-2 py-2 text-left">{h}</th>)}
            </tr>
          </thead>
          <tbody>
            {(samples || []).map((s, i) => (
              <tr key={i} className="odd:bg-slate-900 even:bg-slate-800">
                <td className="px-2 py-2">{s.latitude}</td>
                <td className="px-2 py-2">{s.longitude}</td>
                <td className="px-2 py-2">{s.arsenic}</td>
                <td className="px-2 py-2">{s.cadmium}</td>
                <td className="px-2 py-2">{s.lead}</td>
                <td className="px-2 py-2">{s.zinc}</td>
                <td className="px-2 py-2">{s.result?.heavy_metal_pollution_index}</td>
                <td className="px-2 py-2">{s.result?.hpi_category}</td>
                <td className="px-2 py-2">{s.result?.degree_of_contamination}</td>
                <td className="px-2 py-2">{s.result?.cd_category}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  )
}

/pages/MapView.jsx
import React, { useEffect, useMemo } from 'react'
import { MapContainer, TileLayer, CircleMarker, Popup } from 'react-leaflet'

export default function MapView({ samples = [], preds = [] }) {
  const center = useMemo(() => {
    if (samples.length > 0) return [samples[0].latitude, samples[0].longitude]
    if (preds.length > 0) return [preds[0].latitude, preds[0].longitude]
    return [19.0, 73.0]
  }, [samples, preds])

  return (
    <div className="h-[calc(100vh-56px)]">
      <MapContainer center={center} zoom={8} style={{ height: '100%', width: '100%' }}>
        <TileLayer url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png" attribution="© OpenStreetMap" />
        {samples.map((s, i) => {
          const cat = s.result?.hpi_category || ''
          const color = cat.includes('Low') ? '#22c55e' : cat.includes('Moderate') ? '#60a5fa' : '#ef4444'
          return (
            <CircleMarker key={`s-${i}`} center={[s.latitude, s.longitude]} radius={6} pathOptions={{ color, fillColor: color, fillOpacity: 0.7 }}>
              <Popup>
                <div className="text-sm">
                  <div><b>HPI:</b> {s.result?.heavy_metal_pollution_index}</div>
                  <div><b>Cd:</b> {s.result?.degree_of_contamination}</div>
                  <div><b>Category:</b> {cat}</div>
                </div>
              </Popup>
            </CircleMarker>
          )
        })}
        {preds.map((p, i) => {
          const cat = p.risk_category || ''
          const color = cat.includes('Low') ? '#22c55e' : cat.includes('Moderate') ? '#60a5fa' : '#ef4444'
          return (
            <CircleMarker key={`p-${i}`} center={[p.latitude, p.longitude]} radius={6} pathOptions={{ color, fillColor: color, fillOpacity: 0.5 }}>
              <Popup>
                <div className="text-sm">
                  <div><b>Risk:</b> {p.risk_score}</div>
                  <div><b>Category:</b> {cat}</div>
                </div>
              </Popup>
            </CircleMarker>
          )
        })}
      </MapContainer>
    </div>
  )
}

/pages/PredictView.jsx
import React, { useState, useRef } from 'react'
import Papa from 'papaparse'
import jsPDF from 'jspdf'
import autoTable from 'jspdf-autotable'

const API = (path) => new URL(path, window.location.origin).toString()

export default function PredictView({ preds, setPreds }) {
  const [busy, setBusy] = useState(false)
  const [error, setError] = useState('')
  const [message, setMessage] = useState('')
  const fileRef = useRef(null)

  const upload = async (e) => {
    e.preventDefault()
    setError(''); setMessage('')
    const f = fileRef.current?.files?.[0]
    if (!f) { setError('Select a CSV/JSON file.'); return }
    const fd = new FormData()
    fd.append('file', f, f.name)
    setBusy(true)
    try {
      const res = await fetch(API('/api/v1/predict-hotspots/'), { method: 'POST', body: fd })
      if (!res.ok) throw new Error(await res.text())
      const data = await res.json()
      setPreds(data)
      setMessage(`Predicted ${data.length} hotspots`)
    } catch (err) { setError(String(err)) } finally { setBusy(false) }
  }

  const exportCSV = () => {
    const rows = (preds || []).map(p => ({ latitude: p.latitude, longitude: p.longitude, risk_score: p.risk_score, risk_category: p.risk_category }))
    const csv = Papa.unparse(rows)
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = 'hotspot_predictions.csv'
    a.click()
    URL.revokeObjectURL(url)
  }

  const exportPDF = () => {
    const doc = new jsPDF({ orientation: 'landscape' })
    doc.text('Hotspot Predictions', 14, 14)
    const head = [['Latitude','Longitude','Risk Score','Risk Category']]
    const body = (preds || []).map(p => [p.latitude, p.longitude, p.risk_score, p.risk_category])
    autoTable(doc, { head, body, startY: 20 })
    doc.save('hotspot_predictions.pdf')
  }

  return (
    <div className="p-4">
      <h2 className="text-cyan-300 font-semibold mb-2">Predict Hotspots</h2>
      <form onSubmit={upload} className="flex items-center gap-2">
        <input ref={fileRef} className="file:mr-3 file:px-3 file:py-2 file:bg-slate-700 file:border-0 file:text-slate-100 file:rounded" type="file" accept=".csv,.json" />
        <button className="px-3 py-2 rounded bg-cyan-600 hover:bg-cyan-500" disabled={busy}>{busy? 'Predicting…' : 'Upload'}</button>
        <button type="button" onClick={() => setPreds([])} className="px-3 py-2 rounded bg-slate-700 hover:bg-slate-600">Clear</button>
        <button type="button" onClick={exportCSV} className="px-3 py-2 rounded bg-slate-700 hover:bg-slate-600">Export CSV</button>
        <button type="button" onClick={exportPDF} className="px-3 py-2 rounded bg-slate-700 hover:bg-slate-600">Export PDF</button>
      </form>
      {error && <div className="text-red-300 text-sm mt-2">{error}</div>}
      {message && <div className="text-green-300 text-sm mt-2">{message}</div>}
      <div className="mt-4 text-sm text-slate-300">
        {(preds || []).slice(0, 10).map((p, i) => (
          <div key={i} className="grid grid-cols-4 gap-2 py-1 border-b border-slate-800">
            <div>{p.latitude}</div>
            <div>{p.longitude}</div>
            <div>{p.risk_score}</div>
            <div>{p.risk_category}</div>
          </div>
        ))}
        {preds?.length === 0 && <div className="text-slate-400">No predictions yet.</div>}
      </div>
    </div>
  )
}

app.js
// React via UMD globals provided by index.html
const { useEffect, useMemo, useRef, useState } = React;

const API_BASE = "/api/v1";

async function fetchJSON(url, opts = {}) {
  const res = await fetch(url, opts);
  if (!res.ok) throw new Error(await res.text());
  return res.json();
}

function useIndicesSummary(refreshKey) {
  const [summary, setSummary] = useState(null);
  useEffect(() => {
    fetchJSON(`${API_BASE}/indices/`).then(setSummary).catch(() => setSummary(null));
  }, [refreshKey]);
  return summary;
}

function UploadAndCalculate({ onSamples }) {
  const [busy, setBusy] = useState(false);
  const [error, setError] = useState("");
  const [items, setItems] = useState([]);
  const inputRef = useRef(null);

  const handleUpload = async (e) => {
    e.preventDefault();
    setError("");
    const file = inputRef.current?.files?.[0];
    if (!file) { setError("Please select a CSV/JSON/PDF/Excel file."); return; }
    const fd = new FormData();
    fd.append("file", file, file.name);
    setBusy(true);
    try {
      const data = await fetchJSON(`${API_BASE}/upload-and-calculate/`, { method: "POST", body: fd });
      setItems(data);
      onSamples(data);
    } catch (err) {
      setError(String(err));
    } finally {
      setBusy(false);
    }
  };

  return (
    <div className="section">
      <h2>Upload & Calculate</h2>
      <form onSubmit={handleUpload}>
        <input ref={inputRef} className="input" type="file" accept=".csv,.json,.pdf,.xlsx,.xls" />
        <div style={{ marginTop: 8, display: "flex", gap: 8 }}>
          <button className="btn" type="submit" disabled={busy}>{busy ? "Processing..." : "Upload"}</button>
          <button className="btn secondary" type="button" onClick={() => { setItems([]); onSamples([]); }}>Clear</button>
        </div>
      </form>
      {error && <div style={{ color: "#fca5a5", marginTop: 8 }}>Error: {error}</div>}
      <div className="list">
        {items.length > 0 ? (
          <div>
            <div>{items.length} samples processed</div>
            {items.slice(0, 5).map((s, i) => (
              <div key={i}>
                {s.latitude.toFixed(3)}, {s.longitude.toFixed(3)} · HPI {s.result.heavy_metal_pollution_index} <span className={`badge ${s.result.hpi_category.includes("Low")?"low":s.result.hpi_category.includes("Moderate")?"mod":"high"}`}>{s.result.hpi_category}</span>
              </div>
            ))}
            {items.length > 5 && <div>…and {items.length - 5} more</div>}
          </div>
        ) : <div>No uploaded samples yet.</div>}
      </div>
    </div>
  );
}

function PredictHotspots({ onPreds }) {
  const [busy, setBusy] = useState(false);
  const [error, setError] = useState("");
  const [items, setItems] = useState([]);
  const inputRef = useRef(null);

  const handleUpload = async (e) => {
    e.preventDefault();
    setError("");
    const file = inputRef.current?.files?.[0];
    if (!file) { setError("Please select a CSV/JSON file."); return; }
    const fd = new FormData();
    fd.append("file", file, file.name);
    setBusy(true);
    try {
      const data = await fetchJSON(`${API_BASE}/predict-hotspots/`, { method: "POST", body: fd });
      setItems(data);
      onPreds(data);
    } catch (err) {
      setError(String(err));
    } finally {
      setBusy(false);
    }
  };

  return (
    <div className="section">
      <h2>Predict Hotspots</h2>
      <form onSubmit={handleUpload}>
        <input ref={inputRef} className="input" type="file" accept=".csv,.json" />
        <div style={{ marginTop: 8, display: "flex", gap: 8 }}>
          <button className="btn" type="submit" disabled={busy}>{busy ? "Predicting..." : "Upload"}</button>
          <button className="btn secondary" type="button" onClick={() => { setItems([]); onPreds([]); }}>Clear</button>
        </div>
      </form>
      {error && <div style={{ color: "#fca5a5", marginTop: 8 }}>Error: {error}</div>}
      <div className="list">
        {items.length > 0 ? (
          <div>
            <div>{items.length} predictions</div>
            {items.slice(0, 5).map((p, i) => (
              <div key={i}>
                {p.latitude.toFixed(3)}, {p.longitude.toFixed(3)} · Risk {p.risk_score} <span className={`badge ${p.risk_category.includes("Low")?"low":p.risk_category.includes("Moderate")?"mod":"high"}`}>{p.risk_category}</span>
              </div>
            ))}
            {items.length > 5 && <div>…and {items.length - 5} more</div>}
          </div>
        ) : <div>No predictions yet.</div>}
      </div>
    </div>
  );
}

function Indices() {
  const [refreshKey, setRefreshKey] = useState(0);
  const summary = useIndicesSummary(refreshKey);
  return (
    <div className="section">
      <h2>Indices Summary</h2>
      {summary ? (
        <div className="grid">
          <div>Count: <b>{summary.count}</b></div>
          <div>Avg HPI: <b>{summary.avg_hpi}</b></div>
          <div>Avg Cd: <b>{summary.avg_cd}</b></div>
          <button className="btn secondary" onClick={() => setRefreshKey((x) => x + 1)}>Refresh</button>
        </div>
      ) : (
        <div className="list">No data yet.</div>
      )}
    </div>
  );
}

function Alerts() {
  const [cfg, setCfg] = useState(null);
  const [busy, setBusy] = useState(false);
  const [msg, setMsg] = useState("");
  useEffect(() => { fetchJSON(`${API_BASE}/alerts/config`).then(setCfg).catch(()=>{}); }, []);
  const save = async () => {
    setBusy(true); setMsg("");
    try {
      await fetchJSON(`${API_BASE}/alerts/config`, { method: "PUT", headers: { "Content-Type": "application/json" }, body: JSON.stringify(cfg) });
      setMsg("Saved config");
    } catch (err) { setMsg(String(err)); }
    setBusy(false);
  };
  const send = async (channel) => {
    setBusy(true); setMsg("");
    try {
      const res = await fetchJSON(`${API_BASE}/alerts/send`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ channel, message: "Water quality alert" }) });
      setMsg(`${res.status} via ${res.channel}, recipients: ${res.to || ""}, hotspots: ${res.count}`);
    } catch (err) { setMsg(String(err)); }
    setBusy(false);
  };
  if (!cfg) return (<div className="section"><h2>Alerts</h2><div className="list">Loading config…</div></div>);
  return (
    <div className="section">
      <h2>Alerts</h2>
      <div className="grid">
        <label>HPI Threshold <input className="input" type="number" value={cfg.hpi_threshold} onChange={(e)=>setCfg({...cfg, hpi_threshold: parseFloat(e.target.value)})} /></label>
        <label>Cd Threshold <input className="input" type="number" value={cfg.cd_threshold} onChange={(e)=>setCfg({...cfg, cd_threshold: parseFloat(e.target.value)})} /></label>
        <label>Email recipients <input className="input" type="text" value={cfg.email_recipients} onChange={(e)=>setCfg({...cfg, email_recipients: e.target.value})} /></label>
        <label>SMS recipients <input className="input" type="text" value={cfg.sms_recipients} onChange={(e)=>setCfg({...cfg, sms_recipients: e.target.value})} /></label>
      </div>
      <div style={{ marginTop: 8, display: "flex", gap: 8 }}>
        <button className="btn" onClick={save} disabled={busy}>{busy?"Saving…":"Save Config"}</button>
        <button className="btn secondary" onClick={() => send("email")} disabled={busy}>Send Email</button>
        <button className="btn secondary" onClick={() => send("sms")} disabled={busy}>Send SMS</button>
      </div>
      {msg && <div className="list" style={{ marginTop: 8 }}>{msg}</div>}
    </div>
  );
}

function MapView({ samples, preds }) {
  const mapRef = useRef(null);
  const markersRef = useRef([]);
  const predMarkersRef = useRef([]);

  const allPoints = useMemo(() => {
    const s = (samples || []).map((x) => [x.latitude, x.longitude]);
    const p = (preds || []).map((x) => [x.latitude, x.longitude]);
    return [...s, ...p];
  }, [samples, preds]);

  useEffect(() => {
    if (!mapRef.current) {
      const map = L.map("map").setView([19.0, 73.0], 8);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 19, attribution: "© OpenStreetMap" }).addTo(map);
      mapRef.current = map;
    }
  }, []);

  useEffect(() => {
    // Clear previous sample markers
    markersRef.current.forEach((m) => m.remove());
    markersRef.current = [];
    (samples || []).forEach((s) => {
      const cat = s.result?.hpi_category || "";
      const color = cat.includes("Low") ? "#22c55e" : cat.includes("Moderate") ? "#60a5fa" : "#ef4444";
      const m = L.circleMarker([s.latitude, s.longitude], { radius: 6, color, fillColor: color, fillOpacity: 0.7 })
        .bindPopup(`<b>HPI:</b> ${s.result?.heavy_metal_pollution_index}<br/><b>Cd:</b> ${s.result?.degree_of_contamination}<br/><b>Category:</b> ${cat}`)
        .addTo(mapRef.current);
      markersRef.current.push(m);
    });
  }, [samples]);

  useEffect(() => {
    // Clear previous prediction markers
    predMarkersRef.current.forEach((m) => m.remove());
    predMarkersRef.current = [];
    (preds || []).forEach((p) => {
      const cat = p.risk_category || "";
      const color = cat.includes("Low") ? "#22c55e" : cat.includes("Moderate") ? "#60a5fa" : "#ef4444";
      const m = L.circleMarker([p.latitude, p.longitude], { radius: 6, color, fillColor: color, fillOpacity: 0.5, dashArray: "2,4" })
        .bindPopup(`<b>Risk:</b> ${p.risk_score}<br/><b>Category:</b> ${cat}`)
        .addTo(mapRef.current);
      predMarkersRef.current.push(m);
    });
  }, [preds]);

  useEffect(() => {
    // Fit bounds to all points if available
    if (mapRef.current && allPoints.length > 0) {
      const bounds = L.latLngBounds(allPoints.map(([lat, lng]) => L.latLng(lat, lng)));
      mapRef.current.fitBounds(bounds.pad(0.2));
    }
  }, [allPoints]);

  return null;
}

function App() {
  const [samples, setSamples] = useState([]);
  const [preds, setPreds] = useState([]);
  return (
    <>
      <UploadAndCalculate onSamples={setSamples} />
      <PredictHotspots onPreds={setPreds} />
      <Indices />
      <Alerts />
      <MapView samples={samples} preds={preds} />
    </>
  );
}

const root = createRoot(document.getElementById("root"));
root.render(<App />);

api.py
import pandas as pd
import io
import os
import json
import hashlib
from typing import List, Optional

from fastapi import APIRouter, Depends, UploadFile, File, HTTPException
from sqlalchemy.orm import Session
from pydantic import BaseModel
import tabula  # Import the new library for PDF parsing

from . import models, calculator

# Create an APIRouter instance
router = APIRouter()


# --- Pydantic models for response data structuring (No changes here) ---
class CalculationResult(BaseModel):
    heavy_metal_pollution_index: float
    hpi_category: str
    degree_of_contamination: float
    cd_category: str


class SampleResponse(BaseModel):
    id: int
    latitude: float
    longitude: float
    arsenic: float
    cadmium: float
    lead: float
    zinc: float
    result: CalculationResult

    class Config:
        orm_mode = True


@router.post("/upload-and-calculate/", response_model=List[SampleResponse])
async def create_upload_file(
        file: UploadFile = File(...),
        db: Session = Depends(models.get_db)
):
    """
    Accepts a CSV, JSON, or PDF file with water quality data, calculates 
    pollution indices, stores the data and results in the database, 
    and returns the complete record.

    - CSV/JSON/PDF columns must include: latitude, longitude, arsenic, cadmium, lead, zinc
    """

    df = None
    contents = await file.read()

    # --- NEW: Logic to handle different file types ---
    # Check the content type to decide how to parse the file.

    # 1. Handle CSV files
    if file.content_type == 'text/csv':
        try:
            df = pd.read_csv(io.StringIO(contents.decode('utf-8')))
        except Exception as e:
            raise HTTPException(status_code=400, detail=f"Error processing CSV file: {e}")

    # 2. Handle JSON files
    elif file.content_type == 'application/json':
        try:
            df = pd.read_json(io.StringIO(contents.decode('utf-8')))
        except Exception as e:
            raise HTTPException(status_code=400, detail=f"Error processing JSON file: {e}")

    # 3. Handle PDF files
    elif file.content_type == 'application/pdf':
        try:
            # tabula-py reads a PDF and returns a list of DataFrames (one for each table found)
            pdf_tables = tabula.read_pdf(io.BytesIO(contents), pages='all', multiple_tables=True)
            if not pdf_tables:
                raise HTTPException(status_code=400, detail="No data tables found in the PDF.")
            # We assume the first table found in the PDF is the correct one.
            df = pdf_tables[0]
        except Exception as e:
            raise HTTPException(status_code=400, detail=f"Error processing PDF file: {e}")

    # 4. Handle Excel files (.xlsx)
    elif file.content_type in [
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'application/vnd.ms-excel'
    ]:
        try:
            df = pd.read_excel(io.BytesIO(contents))
        except Exception as e:
            raise HTTPException(status_code=400, detail=f"Error processing Excel file: {e}")

    # If the file type is not supported
    else:
        raise HTTPException(
            status_code=415,
            detail=f"Unsupported file type: {file.content_type}. Please upload a CSV, JSON, or PDF."
        )

    # --- The rest of the logic remains largely the same ---
    # It now operates on the DataFrame 'df' created from the uploaded file.

    # Validate required columns in the resulting DataFrame
    required_columns = {'latitude', 'longitude', 'arsenic', 'cadmium', 'lead', 'zinc'}
    # Column names in PDFs can sometimes have extra spaces, so we strip them.
    df.columns = df.columns.str.strip()

    if not required_columns.issubset(df.columns):
        raise HTTPException(
            status_code=400,
            detail=f"Missing required columns. Data must contain: {', '.join(required_columns)}"
        )

    processed_samples = []

    # Iterate over each row in the DataFrame to process each sample
    for index, row in df.iterrows():
        # 1. Create and save the WaterSample record
        db_sample = models.WaterSample(
            latitude=row['latitude'],
            longitude=row['longitude'],
            arsenic=row.get('arsenic'),
            cadmium=row.get('cadmium'),
            lead=row.get('lead'),
            zinc=row.get('zinc')
        )
        db.add(db_sample)
        db.flush()  # Flush to get the ID for the sample

        # 2. Perform calculations using the calculator module
        hpi_value, hpi_cat = calculator.calculate_hpi(row)
        cd_value, cd_cat = calculator.calculate_degree_of_contamination(row)

        # 3. Create and save the PollutionResult record
        db_result = models.PollutionResult(
            sample_id=db_sample.id,
            heavy_metal_pollution_index=hpi_value,
            hpi_category=hpi_cat,
            degree_of_contamination=cd_value,
            cd_category=cd_cat
        )
        db.add(db_result)

        processed_samples.append(db_sample)

    db.commit()

    # Refresh each sample to load the newly created result relationship
    for sample in processed_samples:
        db.refresh(sample)

    return processed_samples

# =====================
# Removed Authentication & Roles
# =====================
def hash_password(pw: str) -> str:
    return hashlib.sha256(pw.encode("utf-8")).hexdigest()

# Authentication and role-based access removed

class IndicesSummary(BaseModel):
    count: int
    avg_hpi: float
    avg_cd: float

@router.get("/indices/", response_model=IndicesSummary)
async def indices_summary(db: Session = Depends(models.get_db)):
    samples = db.query(models.PollutionResult).all()
    if not samples:
        return IndicesSummary(count=0, avg_hpi=0.0, avg_cd=0.0)
    avg_hpi = sum([s.heavy_metal_pollution_index or 0 for s in samples]) / len(samples)
    avg_cd = sum([s.degree_of_contamination or 0 for s in samples]) / len(samples)
    return IndicesSummary(count=len(samples), avg_hpi=round(avg_hpi, 3), avg_cd=round(avg_cd, 3))


# =====================
# Datasets & Indices API
# =====================

@router.get("/datasets/", response_model=List[SampleResponse])
async def list_datasets(db: Session = Depends(models.get_db)):
    samples = db.query(models.WaterSample).all()
    for s in samples:
        _ = s.result
    return samples

# IndicesSummary moved above


# =====================
# Alerts: config and send
# =====================

class AlertConfigDTO(BaseModel):
    hpi_threshold: float
    cd_threshold: float
    email_recipients: str
    sms_recipients: str
    policy_json: str = "{}"

def _get_config(db: Session) -> models.AlertConfig:
    cfg = db.query(models.AlertConfig).first()
    if not cfg:
        cfg = models.AlertConfig(hpi_threshold=100.0, cd_threshold=3.0)
        db.add(cfg)
        db.commit()
        db.refresh(cfg)
    return cfg

@router.get("/alerts/config", response_model=AlertConfigDTO)
async def get_alert_config(db: Session = Depends(models.get_db)):
    cfg = _get_config(db)
    return AlertConfigDTO(
        hpi_threshold=cfg.hpi_threshold,
        cd_threshold=cfg.cd_threshold,
        email_recipients=cfg.email_recipients or "",
        sms_recipients=cfg.sms_recipients or "",
        policy_json=cfg.policy_json or "{}",
    )

@router.put("/alerts/config", response_model=AlertConfigDTO)
async def update_alert_config(dto: AlertConfigDTO, db: Session = Depends(models.get_db)):
    cfg = _get_config(db)
    cfg.hpi_threshold = dto.hpi_threshold
    cfg.cd_threshold = dto.cd_threshold
    cfg.email_recipients = dto.email_recipients
    cfg.sms_recipients = dto.sms_recipients
    cfg.policy_json = dto.policy_json
    db.add(cfg)
    db.commit()
    db.refresh(cfg)
    return dto

class AlertSendRequest(BaseModel):
    channel: str  # 'email' or 'sms'
    message: str

def _collect_hotspots(db: Session, hpi_thr: float, cd_thr: float):
    items = db.query(models.WaterSample).join(models.PollutionResult).all()
    flagged = []
    for s in items:
        r = s.result
        if not r:
            continue
        if (r.heavy_metal_pollution_index or 0) >= hpi_thr or (r.degree_of_contamination or 0) >= cd_thr:
            flagged.append({
                "latitude": s.latitude,
                "longitude": s.longitude,
                "hpi": r.heavy_metal_pollution_index,
                "cd": r.degree_of_contamination,
            })
    return flagged

@router.post("/alerts/send")
async def send_alerts(req: AlertSendRequest, db: Session = Depends(models.get_db)):
    cfg = _get_config(db)
    hotspots = _collect_hotspots(db, cfg.hpi_threshold, cfg.cd_threshold)
    sendgrid_key = os.getenv("SENDGRID_API_KEY")
    twilio_sid = os.getenv("TWILIO_ACCOUNT_SID")
    twilio_token = os.getenv("TWILIO_AUTH_TOKEN")
    if req.channel == "email":
        if not sendgrid_key:
            raise HTTPException(status_code=400, detail="Missing SENDGRID_API_KEY")
        return {"status": "queued", "channel": "email", "to": cfg.email_recipients, "count": len(hotspots)}
    elif req.channel == "sms":
        if not (twilio_sid and twilio_token):
            raise HTTPException(status_code=400, detail="Missing Twilio credentials")
        return {"status": "queued", "channel": "sms", "to": cfg.sms_recipients, "count": len(hotspots)}
    else:
        raise HTTPException(status_code=400, detail="Unsupported channel")


# =====================
# Predictive Hotspots
# =====================

class PredictionResult(BaseModel):
    latitude: float
    longitude: float
    risk_score: float
    risk_category: str

@router.post("/predict-hotspots/", response_model=List[PredictionResult])
async def predict_hotspots(
        file: UploadFile = File(...),
):
    contents = await file.read()
    df = None
    try:
        if file.content_type == 'text/csv':
            df = pd.read_csv(io.StringIO(contents.decode('utf-8')))
        elif file.content_type == 'application/json':
            df = pd.read_json(io.StringIO(contents.decode('utf-8')))
        else:
            raise HTTPException(status_code=415, detail="Unsupported file type for prediction. Use CSV, JSON, or Excel.")
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error parsing file: {e}")

    required = {'latitude', 'longitude', 'arsenic', 'cadmium', 'lead', 'zinc'}
    df.columns = df.columns.str.strip()
    if not required.issubset(df.columns):
        raise HTTPException(status_code=400, detail=f"Missing required columns. Data must contain: {', '.join(required)}")

    PERMISSIBLE = {'arsenic': 10, 'cadmium': 3, 'lead': 10, 'zinc': 5000}
    weights = {'arsenic': 0.35, 'cadmium': 0.25, 'lead': 0.3, 'zinc': 0.1}

    preds = []
    for _, row in df.iterrows():
        try:
            cf_as = (row['arsenic'] / PERMISSIBLE['arsenic']) if pd.notna(row['arsenic']) else 0
            cf_cd = (row['cadmium'] / PERMISSIBLE['cadmium']) if pd.notna(row['cadmium']) else 0
            cf_pb = (row['lead'] / PERMISSIBLE['lead']) if pd.notna(row['lead']) else 0
            cf_zn = (row['zinc'] / PERMISSIBLE['zinc']) if pd.notna(row['zinc']) else 0
            risk = (
                weights['arsenic'] * cf_as +
                weights['cadmium'] * cf_cd +
                weights['lead'] * cf_pb +
                weights['zinc'] * cf_zn
            )
            risk_score = float(round(1 - (1 / (1 + risk)), 3))
            if risk_score < 0.33:
                cat = 'Low risk'
            elif risk_score < 0.66:
                cat = 'Moderate risk'
            else:
                cat = 'High risk'
            preds.append({
                'latitude': float(row['latitude']),
                'longitude': float(row['longitude']),
                'risk_score': risk_score,
                'risk_category': cat,
            })
        except Exception:
            continue
    return preds


models.py
# app/models.py

from sqlalchemy import create_engine, Column, Integer, String, Float, ForeignKey
from sqlalchemy.orm import declarative_base, sessionmaker, relationship
from sqlalchemy.sql import func
from sqlalchemy import DateTime, Text
from sqlalchemy.orm import declarative_base, sessionmaker, relationship

# Define the database connection URL. For this example, we use a local SQLite file.
# For production, you would replace this with your PostgreSQL connection string.
DATABASE_URL = "sqlite:///./water_quality.db"

# Create the SQLAlchemy engine
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})

# SessionLocal will be the database session class
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Base class for our declarative models
Base = declarative_base()


class WaterSample(Base):
    """
    Represents the raw data for a single water sample point.
    """
    __tablename__ = "water_samples"

    id = Column(Integer, primary_key=True, index=True)
    latitude = Column(Float, nullable=False)
    longitude = Column(Float, nullable=False)

    # Metal concentrations in µg/L
    arsenic = Column(Float, name="As")
    cadmium = Column(Float, name="Cd")
    lead = Column(Float, name="Pb")
    zinc = Column(Float, name="Zn")

    # Establish a one-to-one relationship with the results
    result = relationship("PollutionResult", back_populates="sample", uselist=False)


class PollutionResult(Base):
    """
    Stores the calculated pollution indices for a corresponding water sample.
    """
    __tablename__ = "pollution_results"

    id = Column(Integer, primary_key=True, index=True)
    sample_id = Column(Integer, ForeignKey("water_samples.id"))

    heavy_metal_pollution_index = Column(Float, name="HPI")
    hpi_category = Column(String)

    degree_of_contamination = Column(Float, name="Cd_value")
    cd_category = Column(String)

    # Establish the reverse relationship
    sample = relationship("WaterSample", back_populates="result")


class User(Base):
    """
    Basic user model for authentication with role support.
    Roles: 'Admin', 'Analyst', 'Viewer'.
    """
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    password_hash = Column(String, nullable=False)
    role = Column(String, default="Viewer", nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())


class AlertConfig(Base):
    """
    Stores alert configuration such as thresholds and routing policies.
    Keys for providers are read from environment variables, not stored.
    """
    __tablename__ = "alert_configs"

    id = Column(Integer, primary_key=True, index=True)
    hpi_threshold = Column(Float, default=100.0)
    cd_threshold = Column(Float, default=3.0)
    email_recipients = Column(Text, default="")  # comma-separated emails
    sms_recipients = Column(Text, default="")    # comma-separated phone numbers
    policy_json = Column(Text, default="{}")     # optional JSON string for region policies


def get_db():
    """
    Dependency function to get a database session for each request.
    Ensures the session is closed after the request is finished.
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

main.py
# main.py

from fastapi import FastAPI
from app import api
from fastapi.staticfiles import StaticFiles

# This line has been removed to prevent conflicts with the test database setup.
# models.Base.metadata.create_all(bind=engine)

# Initialize the FastAPI application
app = FastAPI(
    title="Heavy Metal Pollution Index API",
    description="An API to calculate HPI and other pollution indices from water quality data.",
    version="1.0.0",
)

# Include the router from app/api.py
app.include_router(api.router, prefix="/api/v1", tags=["Pollution Indices"])

# Mount static frontend at /app
app.mount("/app", StaticFiles(directory="frontend/static", html=True), name="frontend")

@app.get("/", tags=["Root"])
def read_root():
    """
    Root endpoint providing basic information about the API.
    """
    return {
        "message": "Welcome to the Heavy Metal Pollution Indices API",
        "docs_url": "/docs",
        "app_url": "/app/"
    }

calculator.py
# app/calculator.py

import pandas as pd
import numpy as np

# --- Configuration Constants for Calculations ---
# These values are based on standards (e.g., WHO).
# In a real-world app, these might be configurable or stored in a separate file.

# Standard Permissible Values (S_i) in µg/L
PERMISSIBLE_VALUES = {
    'arsenic': 10,
    'cadmium': 3,
    'lead': 10,
    'zinc': 5000
}

# Unit Weightage (W_i), calculated as the inverse of the permissible value.
UNIT_WEIGHTAGE = {metal: 1 / value for metal, value in PERMISSIBLE_VALUES.items()}


def calculate_hpi(row: pd.Series) -> tuple[float, str]:
    """
    Calculates the Heavy Metal Pollution Index (HPI) for a single water sample.

    HPI is a weighted arithmetic mean of the ratios of metal concentrations
    to their standard permissible values.

    Args:
        row: A pandas Series representing a single sample's metal concentrations.

    Returns:
        A tuple containing the calculated HPI value and its quality category.
    """
    numerator = 0
    denominator = 0

    for metal, weight in UNIT_WEIGHTAGE.items():
        if metal in row and pd.notna(row[metal]):
            concentration = row[metal]
            standard_value = PERMISSIBLE_VALUES[metal]

            # Sub-index (Q_i) = (Concentration / Standard_Value) * 100
            sub_index = (concentration / standard_value) * 100

            numerator += sub_index * weight
            denominator += weight

    if denominator == 0:
        return 0.0, "No Data"

    hpi_value = numerator / denominator

    # Categorize the HPI value
    if hpi_value < 100:
        category = "Low pollution"
    elif 100 <= hpi_value < 150:
        category = "Moderate pollution"
    else:
        category = "High pollution"

    return round(hpi_value, 2), category


def calculate_degree_of_contamination(row: pd.Series) -> tuple[float, str]:
    """
    Calculates the Degree of Contamination (Cd) for a single water sample.

    Cd is the sum of the contamination factors (CF) for each metal, where
    CF is the ratio of the measured concentration to the permissible value.

    Args:
        row: A pandas Series representing a single sample's metal concentrations.

    Returns:
        A tuple containing the calculated Cd value and its quality category.
    """
    cd_value = 0

    for metal, standard_value in PERMISSIBLE_VALUES.items():
        if metal in row and pd.notna(row[metal]):
            concentration = row[metal]
            contamination_factor = concentration / standard_value
            cd_value += contamination_factor

    # Categorize the Cd value
    if cd_value < 1:
        category = "Low degree of contamination"
    elif 1 <= cd_value < 3:
        category = "Moderate degree of contamination"
    else:
        category = "High degree of contamination"

    return round(cd_value, 2), category